게임에서 **AI**라고 하면, 컴퓨터에 의해 제어되며 일정한 의사결정 로직을 가진 모든 엔티티나 에이전트를 뜻합니다.
내비게이션을 위해 A* 같은 경로 탐색 알고리즘을 사용하든, 현재 플레이어 상태를 확인하여 다른 행동으로 전환하는 상태 머신을 사용하든,
혹은 턴제 카드 게임에서 여러 행동 목록 중 하나를 선택하든, 이 모든 것이 게임 AI의 일부입니다.

최근 인공지능 분야의 발전과 대규모 언어 모델(LLM)의 인기 덕분에, 사람들은 LLM을 곧 **“AI”**라고 생각하기 시작했습니다.
그러나 그것은 결코 AI의 유일한 형태가 아닙니다.

**게임 AI**와 **머신러닝**은 서로 다른 목표를 가진 구별되는 분야입니다. 
게임 AI는 주로 플레이어에게 **재미있는 도전 과제**를 만드는 데 초점을 맞춥니다. 
일반적으로 AI를 인간적인 의미에서 정말 “똑똑하게” 만들려고 하지 않습니다.
오히려 미리 정의된 규칙, 휴리스틱, 알고리즘을 사용하여 게임 세계에 맞게 균형 잡힌 도전을 플레이어에게 제공합니다.

반면, 일반 AI와 머신러닝은 새로운 상황을 학습하고 적응하며, 인간의 지능을 모방하고,
궁극적으로는 인간의 지능에 필적하거나 능가할 수 있는 시스템을 만드는 것을 목표로 합니다.

일부 게임은 머신러닝 기법을 도입하기도 하지만, 대부분의 게임 AI는 여전히 전통적이고 결정론적인 접근 방식에 의존하여,
게임이 플레이어에게 균형 있고 재미있도록 유지합니다.

> 참고: 게임 개발자들이 정말 효율적이거나 똑똑한 AI를 코딩할 줄 몰라서 그렇게 하지 않는 것은 아닙니다.
> 여러 가지 이유로 의도적으로 AI를 제한합니다. 예를 들어 **예산, 성능, 개발 시간, 사용자 경험** 등이 있습니다.
> 예를 들어, 컴퓨터가 제어하는 적이 매우 효율적이고 플레이어의 모든 움직임을 예측한다면, 그것을 코딩하는 것은 상대적으로 쉽지만,
> 사실상 이길 수 없고 불공정하게 느껴져 플레이하는 사람이 좌절하게 만들 수 있습니다.

### Common AI techniques used in games

게임 개발자들은 매력적이고 상호작용적인 게임 경험을 만들기 위해 다양한 AI 기법을 활용합니다.
가장 흔히 사용되는 기법에는 다음이 포함됩니다:

- **if 문(!)**
    
- **경로 탐색 알고리즘**
    
- **유한 상태 머신(finite state machines), 행동 트리(behavior trees), 목표 지향적 행동 계획(goal-oriented action planning)**과 같은 구조적 프로그래밍 패턴

#### If statements

**if 문**은 프로그래밍에서 가장 단순한 형태의 의사결정 로직입니다. 조건을 확인하고,
그 조건이 참인지 거짓인지에 따라 다른 코드를 실행할 수 있습니다. 게임 AI에서는 if 문이 자주 사용되며,
플레이어의 근접 여부, 체력 상태, 환경 조건과 같은 요소를 기반으로 NPC의 행동을 결정합니다.
일부 게임은 오직 if 문만으로 만들어지기도 합니다.

다음은 GDScript로 if 문을 사용해 코딩된 AI의 예시입니다. \_physics_process() 함수는 매 프레임마다 호출되며,
플레이어가 일정 범위 안에 있는지를 확인합니다. 만약 플레이어가 범위 안에 있다면 AI는 플레이어를 추격하고,
그렇지 않으면 가만히 대기합니다:

```gdscript
extends CharacterBody2D

@export var detection_range := 600.0

# 이 예시에서는 player 노드가 다른 스크립트에 의해 제공됩니다.
var player: Node2D = null

func _physics_process(delta: float) -> void:
	var distance_to_player := global_position.distance_to(player.global_position)
	var is_player_in_range := distance_to_player < detection_range

	if is_player_in_range:
		# 플레이어 추격
		velocity = global_position.direction_to(player.global_position) * 400.0
	else:
		velocity = Vector2.ZERO
	
	move_and_slide()
```

#### Pathfinding

A* (에이-스타라고 읽습니다)와 같은 경로 탐색 알고리즘이나 내비게이션 메시(navmesh)는 캐릭터가 게임 환경을 탐색할 때
가장 빠른 경로를 결정하는 데 사용됩니다. 이러한 알고리즘은 AI가 게임 레벨을 탐색할 때 막히거나 어리석게 보이지 않도록
하는 데 필수적입니다.

Godot은 경로 탐색을 위해 크게 두 가지 상호 보완적인 옵션을 제공합니다:

- **A* 알고리즘**: 단순하면서도 효율적인 경로 탐색 알고리즘으로, 격자 기반 게임이나 직접 그래프 구조를 만들 때 유용합니다. 예를 들어, 마리오와 같은 게임에서 월드맵을 탐색하기 위해 사용할 수 있습니다. 격자나 그래프 상에서 두 지점 간의 최단 경로를 찾는 데 활용할 수 있습니다.
    
- **내비게이션 서버**: 내비게이션 메시를 사용하여 캐릭터가 따라갈 경로를 만드는 더 복잡한 시스템입니다. Godot 에디터는 게임 레벨을 분석하고, 이동 가능한 영역을 나타내는 기하학적 형태를 생성할 수 있는 도구를 제공합니다. 내비게이션 서버는 이러한 형태들을 기반으로 캐릭터가 따라갈 경로를 계산할 수 있습니다.

참고로, 이러한 시스템은 AI 전용이 아닙니다. 예를 들어, 플레이어가 클릭한 위치로 캐릭터가 이동하는 시스템을 만드는 데에도 활용할 수 있습니다.

#### Structural programming patterns

게임 AI가 점점 더 복잡해지고, 게임 안에서 다양한 AI가 필요해질수록, 코드를 체계적으로 정리하기 위해 더 정교한 구조를 사용하는 것이
합리적일 수 있습니다. 특히, 프로그래밍을 모르는 팀원들이 AI 제작을 돕는 상황이라면 더욱 그렇습니다.

지난 20여 년간 게임에서 가장 흔히 사용된 세 가지 구조는 다음과 같습니다:

- **유한 상태 머신(Finite State Machine, FSM)**:
    
    이 패턴에서 AI는 여러 상태와 그 상태들 간의 전환을 가집니다. 각 상태는 하나의 행동을 나타내며, 전환은 상태 변화를 일으키는 조건을 나타냅니다. 이는 인디 게임에서 기본적인 방식으로, 예를 들어 _Hollow Knight_ 에서 사용되었으며, 매우 복잡한 게임에도 확장 가능합니다. id Software는 *DOOM (2016)* 과 _Wolfenstein: The New Order_ 같은 FPS 게임에서 FSM의 변형을 사용했습니다. FSM은 패턴을 따르고 예측 가능한 행동을 해야 하는 적에게 특히 잘 맞지만, 그것만을 위한 것은 아닙니다.
    
- **목표 지향 행동 계획(Goal-Oriented Action Planning, GOAP)**:
    
    이 패턴에서 AI는 여러 목표와 그것을 달성하기 위해 수행할 수 있는 행동들을 가집니다. AI는 게임의 현재 상태를 기반으로 목표를 달성하는 데 가장 적합한 행동을 선택합니다. 이를 통해 AI는 유연해지고 다양한 상황에 적응할 수 있습니다. 이 구조는 고전 FPS 게임 _FEAR_ 에서 사용되었습니다.
    
- **행동 트리(Behavior Trees)**:
    
    이 패턴에서는 작은 논리 노드들을 조합해 트리 형태를 만들어 복잡한 행동을 구성합니다. 행동 트리는 마치 AI를 위한 작은 프로그래밍 언어와도 같습니다. 노드는 행동이나 조건 분기를 나타내며, 행동들을 순서대로 실행하거나 선택하는 역할을 합니다. 이 접근 방식은 _Halo 2_ 에서 널리 알려졌으며, 이후 수많은 AAA 게임에서 광범위하게 사용되었습니다. Godot에는 **Beehave** 라는 강력한 플러그인이 있어, 이를 활용해 행동 트리를 구현할 수 있습니다.
    

각 패턴은 이전 것보다 더 많은 유연성을 제공하지만, 그 대가로 복잡성도 증가합니다. **FSM** 은 개념적으로 가장 단순하며, **행동 트리** 는 가장 강력하고 복잡한 옵션입니다.

> [!info]- 내 게임에 맞는 패턴을 어떻게 선택해야 하나요?
> 실제로 패턴들을 실험해 보면서 어떤 것이 자신의 게임에 가장 적합한지 평가하는 것 외에는 방법이 없습니다. 저는 항상 가능한 한 가장 단순한 코드로 AI를 설계하고, 필요할 때 리팩터링할 것을 권장드립니다. 작은 실험을 통해 여러 패턴을 사용해 프로토타입을 만들어 보고, 어떤 것이 게임에 가장 잘 맞는지 확인할 수 있습니다. 좋은 실험 방법은, 두세 명의 몹을 게임에서 뽑아내어, 한두 명의 개발자가 동일한 몹을 두세 가지 다른 패턴으로 구현해 보는 것입니다. 그러면 결과를 비교하면서 어떤 방식이 더 이해하기 쉽고 유지보수가 용이한지 판단할 수 있습니다.
> 
> 만약 이러한 패턴들에 대한 경험이 없고 당장 시작하고 싶으시다면, 우선 **if 문을 사용한 단순한 코드** 로 시작하시기를 권합니다. 그리고 그 방식의 한계에 도달했을 때, **유한 상태 머신(FSM)** 으로 넘어가시면 됩니다.

> 참고: 다른 두 가지 패턴과 달리, **FSM(유한 상태 머신)** 은 AI뿐만 아니라 플레이어 캐릭터와 다른 게임 시스템에도 사용됩니다. 이는 복잡한 시스템을 관리 가능한 단위로 나누는 하나의 방법입니다. 더 자세한 내용은 여기에서 확인하실 수 있습니다: [[Finite State Machine]].




