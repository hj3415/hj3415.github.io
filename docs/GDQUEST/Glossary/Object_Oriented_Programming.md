객체 지향 프로그래밍(Object-oriented programming)은 프로그램을 객체라고 불리는 추상적인 작은 기계들로 나누어 구성하는 방식의 프로그래밍입니다.

객체란 데이터(변수)와 동작(함수)을 하나로 묶은 집합입니다. 객체는 자신의 데이터를 그 객체에 정의된 함수들을 통해 스스로 처리할 수 있습니다.
예를 들어, Godot에서 Sprite2D 노드는 position이라는 데이터를 가지고 있으며, translate 함수를 호출하면 스프라이트가 이동하면서 위치가 바뀌게 됩니다.

객체 지향 프로그래밍에서 객체의 핵심 개념은, 프로그램 내에서 유용한 작업을 수행하기 위해 필요한 코드와 데이터를 모두 캡슐화(하나로 묶음)한다는 점입니다.
예를 들어, 화면에 표시되는 스프라이트 하나는 위치를 바꾸거나 회전시킬 수 있으며, 이는 하나의 객체로 볼 수 있습니다.
또한, 시간을 카운트다운하고 시간이 다 되면 신호(signal)를 발생시키는 타이머 노드도 또 다른 객체입니다.

원래 객체는 “가상 기계(virtual machines)”라고 불렸으며, 텍스트 형식으로 메시지를 주고받으며 서로 소통하는 것을 목표로 했습니다.
오늘날에도 이러한 텍스트 기반 인터페이스(즉, 함수 이름을 적어서 호출하는 방식)는 유지되고 있지만, 객체들은 초기 개념만큼 완전히 독립적이고
밀폐된 존재는 아닙니다.

객체 지향 프로그래밍과 함께 널리 알려진 또 하나의 개념은 [Inheritance](Inheritance.md)입니다.
상속은 기존 객체와 유사한 새로운 객체를 만드는 방법입니다.
예를 들어, Godot에서는 Sprite2D의 모든 속성과 메서드를 상속받는 새로운 MySprite2D 클래스를 만들고, 여기에 새로운 기능을 추가할 수 있습니다.
오늘날 “객체 지향 프로그래밍”이라고 말할 때는 보통 이 “상속” 개념을 의미하는 경우가 많습니다.
그 외 객체 지향의 다른 기능들은 사실 다른 프로그래밍 패러다임에서도 찾아볼 수 있습니다.

상속은 종종 한계가 있습니다.
예를 들어, 플레이어 유닛과 적 유닛이 있다고 가정해 보겠습니다. 이 둘은 Unit 클래스를 상속받도록 만들 수 있습니다.
하지만 만약 날 수 있는 플레이어 유닛이 필요하다면 어떻게 할까요?
이 경우, 해당 유닛이 Player와 FlyingUnit을 동시에 상속받을 수는 없습니다.
이럴 때 사용하는 개념이 [Composition](Composition.md)입니다.
이 문제는 너무 흔해서, 프로그래밍 세계에서는 “상속보다 컴포지션(composition over inheritance)”이라는 문장이 널리 퍼져 있는 격언처럼
여겨질 정도입니다.

하나의 객체는 여러 다른 객체들과 구성되어, 더 고급스럽고 강력한 엔티티로 확장될 수 있습니다.
예를 들어, Godot에서는 달리고 점프할 수 있는 플레이어 캐릭터를 만들기 위해 다음과 같은 구성 요소들이 함께 사용될 수 있습니다:
충돌 감지를 위한 CharacterBody2D 노드, 이미지를 표시하기 위한 Sprite2D 노드, 소리를 재생하기 위한 AudioStreamPlayer 노드 등입니다.
이렇게 하나의 객체(CharacterBody2D 노드)가 씬의 루트에 있고, 그 아래에 여러 다른 객체들(Sprite2D, AudioStreamPlayer 등)이 포함되어 있습니다.

어떤 면에서 보면, 객체 지향 프로그램은 여러 개의 작은 프로그램들이 협력하여 복잡한 문제를 나누어 정복하는 방식이라고 생각할 수 있습니다.

이 방식이 프로그램의 복잡성을 분해하는 유일한 방법은 아니지만, 비디오 게임 분야와 몇몇 소프트웨어 개발 분야에서는 가장 널리 사용되는
프로그래밍 스타일이 되었습니다.