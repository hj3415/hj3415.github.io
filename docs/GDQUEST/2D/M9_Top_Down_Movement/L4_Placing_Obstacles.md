이전 강의에서는 모든 방향으로 이동할 수 있는 캐릭터를 만들었습니다. 하지만 장애물이 없다면 그다지 재미있지는 않겠죠!
이번 강의에서는 게임에 벽을 추가하여 move_and_slide() 기능을 테스트해 보겠습니다.

이번 강의에서 여러분은 다음을 배우게 됩니다:

- 러너 캐릭터의 움직임을 막는 간단한 정사각형 장애물을 만드는 방법
- 캐릭터가 주행할 수 있는 경로(레이싱 서킷)를 복잡한 충돌 형태로 구성하는 방법
- 캐릭터를 따라다니는 카메라를 추가하는 방법

![030_000_blocks_and_circuit.mp4](videos/030_000_blocks_and_circuit.mp4)

---

## P1 Creating blocks

먼저, 간단한 정사각형 블록 씬을 만들어 보겠습니다. 이 작업을 완료하면 러너 캐릭터와 충돌할 수 있는 장애물이 생기게 됩니다.
이 장애물은 게임 레벨 내에서 필요할 만큼 복제하여 사용할 수 있습니다.

![030_010_blocks.mp4](videos/030_010_blocks.mp4)

이 장애물의 구조는 앞서 M4 강의에서 만들었던 Area2D 우주선 씬이나, 이전 강의에서 만들었던 CharacterBody2D 러너 씬과 거의 유사합니다.
즉, StaticBody2D를 루트 노드로 하고, 그 아래에 Sprite2D와 CollisionShape2D를 자식 노드로 추가하여 구성합니다.

> [!note] 직접 시도해 보세요
> StaticBody2D 씬을 직접 만들어 보시겠어요? 스프라이트에 사용할 텍스처 이미지는 resassets/simple_obstacle.svg 경로에 있습니다. StaticBody2D의 크기는 스프라이트의 크기와 대략 일치하도록 만들어 주세요.
> 
> 필요한 노드는 총 세 개입니다: StaticBody2D, Sprite2D, 그리고 CollisionShape2D입니다. 씬 구조는 다음과 같아야 합니다:
> 
> ![030_005_simple_obstacle 1.webp](images/030_005_simple_obstacle%201.webp)
> 
> 완료하셨으면 다시 이 글로 돌아와 주세요. 이제 캐릭터가 장애물 뒤로 걸어갈 수 있도록 함께 조정해 보겠습니다.

아직 장애물을 만들지 않으셨다면, 다음은 장애물을 만들기 위한 구체적인 단계입니다:

1. StaticBody2D 루트 노드를 생성합니다.
    
2. 자식 노드로 Sprite2D 노드를 추가합니다.
    
3. 자식 노드로 CollisionShape2D 노드를 추가합니다.
    
4. CollisionShape2D 노드에 쉐이프 리소스를 지정해 줍니다.
    
5. 쉐이프의 크기를 스프라이트보다 약간 작게 조정하여, 캐릭터가 블록의 앞이나 뒤를 걸을 수 있도록 합니다.

이미 씬을 만들어두셨다면, 계속 따라오시면서 필요한 부분을 조정해 주세요.

res://lessons 폴더에 새 씬을 생성하고 이름을 simple_obstacle.tscn으로 지정해 주세요. 루트 노드는 StaticBody2D로 선택하시고,
이름은 SimpleObstacle로 지정해 주세요. 그런 다음 StaticBody2D의 자식으로 스프라이트 노드를 추가하고,
해당 노드에 simple_obstacle.svg 텍스처를 할당해 주세요.

그 다음으로, StaticBody2D 노드의 자식으로 CollisionShape2D를 추가하시고, 해당 노드의 Shape 속성에 RectangleShape2D를 할당해 주세요.

충돌 쉐이프를 더 잘 볼 수 있도록 색상을 조절할 수 있습니다. CollisionShape2D 노드를 선택하신 후,
인스펙터에서 Debug Color 속성을 밝고 투명한 빨간색으로 변경해 주세요.

**참고:** 이 충돌 쉐이프의 시각적 표시(드로잉)는 기본적으로 에디터에서만 표시됩니다.

![030_000_simple_obstacle.webp](images/030_000_simple_obstacle.webp)

이제 사각형 쉐이프의 크기를 조절해 보겠습니다. 여기에는 미묘한 부분이 있습니다! 사각형 쉐이프로 스프라이트의 일부분만 덮도록 해야 합니다.
이전 강의에서 설명드린 것처럼, 스프라이트는 게임의 시각적 표현이며, 실제 충돌 계산은 물리 엔진이 물리 쉐이프를 기준으로 수행합니다.
따라서 캐릭터가 블록의 앞과 뒤를 자유롭게 걸을 수 있도록, 쉐이프는 스프라이트보다 작게 만들어야 합니다.

쉐이프의 너비는 스프라이트와 맞춰 주시고, 높이는 위쪽과 아래쪽 부분을 비워 주세요. 참고용으로 임시로 러너 씬 인스턴스를 추가해 보셔도 좋습니다.
러너의 충돌 원형이 블록에 닿을 때 플레이어가 멈추게 될 것입니다.

![030_010_character_and_obstacle.webp](images/030_010_character_and_obstacle.webp)

단축키를 사용하면 쉐이프의 크기를 대칭적으로 조절할 수 있다는 점을 기억해 주세요.

#### 장애물 테스트하기

이제 이 장애물을 테스트할 수 있는 씬을 만들어 보겠습니다. res://lessons 폴더에 새 씬을 생성하시고, 이름은 game.tscn으로 지정해 주세요.
루트 노드는 Node2D로 선택하시고, runner.tscn과 simple_obstacle.tscn 씬을 인스턴스로 추가해 주세요. 
두 씬 파일을 파일 시스템 독(FileSystem dock)에서 동시에 선택한 후 뷰포트로 드래그하시면 됩니다.

씬 구조는 다음과 같아야 하며, **러너가 장애물보다 위쪽에 위치하도록** Scene 독에서 배치해 주세요.

![030_015_game_scene.webp](images/030_015_game_scene.webp)

원하신다면 SimpleObstacle 노드를 선택하여 여러 번 복제하실 수 있습니다.

직접 테스트해 보세요! 작동은 잘 되지만, 약간의 문제가 있습니다. 캐릭터가 블록 뒤로 이동할 때는 잘 그려지지만,
캐릭터가 아래쪽으로 내려오면 여전히 장애물 뒤에 그려져서 깊이감이 있는 것처럼 보이던 연출이 깨지게 됩니다.

![030_020_blocks_problem.mp4](videos/030_020_blocks_problem.mp4)

지금이 바로 **그리기 순서(drawing order)** 에 대해 소개하고 설명드리기에 좋은 기회입니다.

---

## P2 Draw order

기본적으로 Godot의 2D에서는 씬 트리(Scene Tree)에 나타나는 순서대로 노드를 그립니다. 위에서 아래로 순서대로 그려지며,
씬 트리의 위쪽에 있는 노드가 먼저, 즉 뒤쪽에 그려지고, 아래쪽에 있는 노드일수록 나중에, 즉 앞쪽에 그려집니다.

이러한 기본 동작은 대부분의 게임이나 사용자 인터페이스에서는 잘 작동합니다. 그러나 탑다운(top-down)이나 아이소메트릭(isometric) 방식의 
게임에서는 그렇지 않습니다. 이러한 게임에서는 씬 트리에서의 순서가 아니라 **화면상의 위치** 를 기준으로 노드를 그려야 합니다. 그리고 씬 트리에서의
순서와 화면상의 위치는 항상 일치하지 않습니다!

Godot는 2D 노드의 그리기 순서를 제어할 수 있는 몇 가지 도구를 제공합니다. 그중 첫 번째가 **Z 인덱스(Z Index)** 속성입니다.
Z 인덱스가 높은 노드는 낮은 노드보다 **앞쪽에 표시** 됩니다.

현재 씬에서 러너가 블록의 아래쪽과 겹치도록 배치한 후, 블록의 Z 인덱스 속성을 조절해 보세요. 씬 독(Scene dock)에서 러너가 블록보다 위쪽에 위치해 있으면,
블록이 **앞쪽에 그려져서** 러너를 가리게 됩니다. 하지만 블록의 Z 인덱스를 낮추면, 블록이 **러너 뒤쪽에 그려지는** 것을 확인하실 수 있습니다.

![030_025_z_index.mp4](videos/030_025_z_index.mp4)

좋습니다, 문제가 해결된 것 같죠? 하지만… 정말 해결된 걸까요?

러너를 블록의 위쪽으로 이동시켜 보면, 여전히 러너가 블록 **앞에 그려지는** 것을 보실 수 있습니다. 
즉, 에디터에서 Z 인덱스를 수동으로 조절하는 것만으로는 이번 경우에 완전히 원하는 결과를 얻을 수 없습니다.

![030_027_z_index_problem.mp4](videos/030_027_z_index_problem.mp4)

문제는 다음과 같습니다:

- 캐릭터가 뷰포트에서 블록보다 **위쪽에 위치** 해 있을 때는, **블록이 캐릭터 앞에 그려지기를** 원합니다.
    
- 반대로 캐릭터가 블록보다 **아래쪽에 위치** 해 있을 때는, **블록이 캐릭터 뒤에 그려지기를** 원합니다.

아하! 그렇다면 런타임 중에 두 노드 중 하나의 Z 인덱스를 **동적으로 변경** 할 수 있겠네요! 장애물과 러너의 position.y 속성을 비교해서,
그에 따라 Z 인덱스를 조절하는 방식입니다. 하지만 게임에 더 많은 오브젝트들이 추가되면, **게임 안의 모든 블록과 캐릭터 각각에 대해** 이런 처리를 해줘야 합니다… 
생각보다 꽤 많은 작업이 될 것 같네요.

---

## P3 Y-sort

다행히도, 우리가 직접 코딩할 필요는 없습니다! 이 문제는 워낙 흔하게 발생하기 때문에, Godot 엔진에서는 이를 자동으로 처리해 주는 속성을 제공합니다.
바로 **Y Sort Enabled** 속성입니다.

> [!example] 다음 질문에 답해보세요
> **이 속성이 무슨 역할을 한다고 생각하시나요?** 최선을 다해 추측해 보세요.
> - 노드들의 **Y 위치** 를 기준으로 그리기 순서를 변경합니다.
> - 노드들의 **Z 위치** 를 기준으로 그리기 순서를 변경합니다.
> - **y 속성** 이 있는 노드만 그립니다.
> - 노드들의 **X 위치** 를 기준으로 그리기 순서를 변경합니다.
> - “y”라는 그룹에 속한 노드들만 그리기 순서를 변경합니다.
> > [!example]- 정답
> > Y Sort Enabled 속성은 해당 노드의 **모든 자식 노드들의 Y 위치를 기준으로 정렬** 하여, 그 순서대로 그려지게 합니다. 이는 스프라이트가 화면 위아래로 이동하면서 **다른 스프라이트의 앞이나 뒤로 자연스럽게 이동하도록 표현하고 싶을 때** 매우 유용합니다.

Y Sort Enabled 속성을 사용하면, 노드의 순서와 관계없이 position.y 값이 더 큰 노드가 position.y 값이 더 작은 노드 위에 그려지도록 할 수 있습니다.
참고로, position.y 값은 노드가 화면 아래쪽으로 이동할수록 증가합니다. 따라서 position.y 값이 클수록 캐릭터는 화면에서 더 아래쪽에 위치하게 됩니다.
예를 들어, 아래의 다이어그램에서는 Godot이 A 위에 B 노드를 그리게 됩니다.

![030_030_ysort_example_01_example.webp](images/030_030_ysort_example_01_example.webp)

노드의 모양이나 시각적 요소는 중요하지 않다는 점에 유의해 주세요. 중요한 것은 노드의 피벗 포인트이며, 이는 에디터의 뷰포트에 작은 십자 모양으로 표시됩니다.

피벗 포인트가 스프라이트의 중심에 위치해 있다면, B 노드의 크기를 A보다 작게 만들 경우 그려지는 순서가 어색하게 보일 수 있습니다.

![030_030_ysort_example_02_smaller.webp](images/030_030_ysort_example_02_smaller.webp)

이것은 탑다운 게임에서 흔히 발생하는 문제입니다. 더 큰 스프라이트가 다른 스프라이트 앞에 그려지게 하고 싶다면,
노란색 스프라이트의 피벗 포인트를 이미지의 아래쪽으로 옮기는 것이 하나의 해결책입니다.

위의 예시에서, 만약 스프라이트 A의 피벗 포인트를 이미지의 아래쪽에 맞춰 이동시킨다면,
Y Sort Enabled가 활성화된 상태에서 Godot은 A를 B 위에 그리게 됩니다.

![030_030_ysort_example_03_pivot_point.webp](images/030_030_ysort_example_03_pivot_point.webp)

**참고:** Y Sort Enabled는 부모 노드에 설정해야 하며, 이 속성은 해당 부모 노드의 모든 자식 노드에 적용됩니다.

좋습니다! 이제 우리 프로젝트에서 Y Sort Enabled 속성을 사용해 보겠습니다. Game 노드를 선택한 다음,
인스펙터에서 **Ordering > Y Sort Enabled** 체크박스를 활성화해 주세요.

![030_040_y_sort_enabled.webp](images/030_040_y_sort_enabled.webp)

이제 씬을 다시 테스트해 보세요. 캐릭터가 블록 위쪽으로 이동할 때, 이제는 블록 뒤에 그려져야 합니다. 멋지죠! 씬을 잠깐 플레이해 보세요.

하지만 또 다른 문제가 있다는 것을 눈치채실 수도 있습니다. 만약 아직 못 보셨다면, 제가 보여드리겠습니다.
캐릭터가 블록보다 훨씬 일찍 뒤에 그려지기 시작하는데, 이것이 다소 어색하게 보일 수 있습니다.

![030_050_blocks_problem_02.mp4](videos/030_050_blocks_problem_02.mp4)

> [!example] 다음 질문에 답해보세요
> 무슨 일이 일어나고 있다고 생각하시나요?
> - 캐릭터가 블록에서 너무 멀리 떨어졌을 때 블록 뒤에 그려진다
> - 캐릭터의 position.y 값이 블록보다 작을 때 블록 뒤에 그려진다
> - 캐릭터가 블록에 너무 가까이 있을 때 블록 뒤에 그려진다
> - 캐릭터가 블록과 같은 높이에 있을 때 블록 뒤에 그려진다
> > [!example]- 정답
> > Y Sort Enabled 속성은 노드들을 Y 위치에 따라 정렬합니다. 블록의 피벗 위치만이 중요하기 때문에, 달리는 캐릭터의 피벗 포인트가 블록의 중심을 지나치게 되면, Godot은 캐릭터를 블록 뒤에 그리게 됩니다.

---

## P4 Adjusting the pivot point

이제 블록의 피벗 포인트를 조정해 보겠습니다. 좀 더 정확히 말하자면, 노드들을 이동시켜 블록의 위치가 스프라이트의 상단 근처에 오도록 하겠습니다.
이렇게 하면, 캐릭터가 블록의 윗부분 가까이에 있을 때에만 블록이 캐릭터 앞에 그려지게 됩니다.

simple_obstacle.tscn 씬을 열어 주세요.

장애물의 피벗 포인트는 루트 노드인 StaticBody2D의 위치입니다.
이 위치는 해당 노드를 선택했을 때 에디터에서 밝게 표시되는 위치 아이콘으로 확인하실 수 있습니다.

![030_055_pivot_point.webp](images/030_055_pivot_point.webp)

문제는 StaticBody2D 노드를 이동하면 스프라이트와 충돌 모양도 함께 이동하게 된다는 점입니다. 그래서 이렇게 하는 것은 실제로 도움이 되지 않습니다.
대신, 스프라이트와 충돌 모양 노드를 직접 이동시켜서 블록의 피벗 포인트를 효과적으로 변경해야 합니다.

  <br>

Sprite2D와 CollisionShape2D 노드를 함께 선택해 주세요. 두 노드를 모두 선택한 상태에서 Transform > Position > Y 값을 74픽셀로 설정하시면 됩니다.

![030_060_pivot_point.webp](images/030_060_pivot_point.webp)

이렇게 하면 스프라이트의 상단이 StaticBody2D 노드의 위치와 정렬되게 됩니다.

![030_065_pivot_point_adjusted.webp](images/030_065_pivot_point_adjusted.webp)

이제 다시 Game 씬으로 돌아가서 테스트해 보세요. Godot은 캐릭터가 블록의 윗부분 가장자리에 가까이 있을 때에만 캐릭터를 블록 뒤에 그려야 합니다.
정확히 말로 표현하기는 어렵지만, 그려지는 순서의 변화가 훨씬 더 자연스럽게 느껴질 것입니다.

![030_067_blocks_fixed.mp4](videos/030_067_blocks_fixed.mp4)

이렇게 하면 캐릭터가 충돌할 수 있으면서, 그 뒤와 앞을 자유롭게 지나갈 수 있는 오브젝트를 설정할 수 있습니다.

이제 장애물이 잘 작동하니, 달리는 캐릭터를 위한 경로를 만들어 봅시다!


